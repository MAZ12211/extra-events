import funkin.play.PlayState;
import flixel.FlxG;

import funkin.play.event.SongEvent;
import funkin.data.event.SongEventSchema;

import funkin.modding.PolymodErrorHandler;
import funkin.play.event.ScriptedSongEvent;

import funkin.modding.module.ModuleHandler;
import funkin.modding.module.ScriptedModule;
import funkin.data.event.SongEventRegistry;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import funkin.Preferences;
import funkin.save.Save;

class addLyricsHandler extends ScriptedModule {
  function new() {
    super("extra-events-addLyricsHandler", 30);
    this.active = Save.instance?.modOptions?.get('extra-events')?.isLyricsEnabled;
  }

  public var lyricObj:FlxText = null;
  public var lyricObj2nd:FlxText = null;

  var lyricObj_YPos_UPSCROLL:Float = FlxG.height * 0.7; // OFFSET IS 0.05
  var lyricObj_YPos_DNSCROLL:Float = FlxG.height * 0.25;
  var lyricObj2nd_YPos_UPSCROLL:Float = FlxG.height * 0.75;
  var lyricObj2nd_YPos_DNSCROLL:Float = FlxG.height * 0.3;

//   var isItalicArg = null;
//   var isBoldArg = null;
//   var hasAntiAliasingArg = null;
//   var opacityArg = null;
//   var letterSpacingArg = null;
//   var textBorderColorArg = null;
//   var borderSizeArg = null;
  

  function createText(?text:String, ?duration:Float = 0, ?textColor:Int, ?font:String, ?fontSize:Float, ?isItalic:Bool, ?isBold:Bool, ?hasAntiAliasing:Bool, ?isCentered:Bool, ?opacity:Float, ?letterSpacing:Float, ?textBorderColor:Int, ?borderSize:Float, ?isBehindStrumLines:Bool) {
    if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
    // Prevents stacking the current text by deleting the current one
    if (lyricObj != null) {
      lyricObj.kill();
      lyricObj.destroy();
      lyricObj = null;
    }

    var textArg = text ?? DEFAULT_TEXT;
    var durationArg = duration;
    var textColorArg = textColor ?? DEFAULT_COLOR;
    var fontArg = font ?? DEFAULT_FONT;
    var fontSizeArg = fontSize ?? DEFAULT_FONTSIZE;
    var isItalicArg = isItalic ?? DEFAULT_ITALIC;
    var isBoldArg = isBold ?? DEFAULT_BOLD;
    var hasAntiAliasingArg = hasAntiAliasing ?? DEFAULT_HAS_ANTIALIASING;
    var isCenteredArg = isCentered ?? DEFAULT_ISCENTERED;
    var opacityArg = opacity ?? DEFAULT_OPACITY;
    var letterSpacingArg = letterSpacing ?? DEFAULT_LATTERSPACING;
    var textBorderColorArg = textBorderColor ?? DEFAULT_BORDERCOLOR;
    var borderSizeArg = borderSize ?? DEFAULT_BORDERSIZE;
    var isBehindStrumLinesArg = isBehindStrumLines ?? DEFAULT_ISBEHINDSTRUMLINES;

    // I'm sure they'll have a color picker at some point
    switch (textColorArg) {
      case 0: // Black
        textColorArg = 0xFF000000;
      case 1: // Blue
        textColorArg = 0xFF0000FF;
      case 2: // Brown
        textColorArg = 0xFFA52A2A;
      case 3: // Cyan
        textColorArg = 0xFF00FFFF;
      case 4: // Gray
        textColorArg = 0xFF808080;
      case 5: // Green
        textColorArg = 0xFF008000;
      case 6: // Lime
        textColorArg = 0xFF00FF00;
      case 7: // Magenta
        textColorArg = 0xFFFF00FF;
      case 8: // Orange
        textColorArg = 0xFFFFA500;
      case 9: // Purple
        textColorArg = 0xFF800080;
      case 10: // Red
        textColorArg = 0xFFFF0000;
      case 11: // Transparent
        textColorArg = 0x00000000;
      case 12: // White
        textColorArg = 0xFFFFFFFF;
      case 13: // Yellow
        textColorArg = 0xFFFFFF00;
      default:
        textColorArg = 0xFFFFFFFF;
    }

    switch (textBorderColorArg) {
      case 0: // Black
        textBorderColorArg = 0xFF000000;
      case 1: // Blue
        textBorderColorArg = 0xFF0000FF;
      case 2: // Brown
        textBorderColorArg = 0xFFA52A2A;
      case 3: // Cyan
        textBorderColorArg = 0xFF00FFFF;
      case 4: // Gray
        textBorderColorArg = 0xFF808080;
      case 5: // Green
        textBorderColorArg = 0xFF008000;
      case 6: // Lime
        textBorderColorArg = 0xFF00FF00;
      case 7: // Magenta
        textBorderColorArg = 0xFFFF00FF;
      case 8: // Orange
        textBorderColorArg = 0xFFFFA500;
      case 9: // Purple
        textBorderColorArg = 0xFF800080;
      case 10: // Red
        textBorderColorArg = 0xFFFF0000;
      case 11: // Transparent
        textBorderColorArg = 0x00000000;
      case 12: // White
        textBorderColorArg = 0xFFFFFFFF;
      case 13: // Yellow
        textBorderColorArg = 0xFFFFFF00;
      default:
        textBorderColorArg = 0xFF000000;
    }

    lyricObj = new FlxText(0, 0, FlxG.width);
    lyricObj.text = textArg;
    lyricObj.setFormat(Paths.font(fontArg + ".ttf"), fontSizeArg, textColorArg, "center", FlxTextBorderStyle.OUTLINE, textBorderColorArg);
    lyricObj.borderSize = borderSizeArg;
    lyricObj.alpha = opacityArg;
    lyricObj.letterSpacing = letterSpacingArg;
    lyricObj.italic = isItalicArg;
    lyricObj.bold = isBoldArg;
    lyricObj.antialiasing = hasAntiAliasingArg;
    lyricObj.cameras = [PlayState.instance.camHUD];
    lyricObj.screenCenter(isCenteredArg ? 0x11 : 0x01); // I love ternary operators
    if (!isCenteredArg || !isCentered) {
      lyricObj.y = (Preferences.downscroll ? lyricObj_YPos_DNSCROLL : lyricObj_YPos_UPSCROLL); // Dynamic positioning
    } else {
      if (lyricObj2nd != null && lyricObj2nd.x == ((FlxG.width - lyricObj2nd.width) / 2) && lyricObj2nd.y == ((FlxG.height - lyricObj2nd.height) / 2)) {
        lyricObj.y -= (lyricObj2nd.height - 5);
      }
    }

    if (PlayState.instance.opponentStrumline == null) return;
    for (strumLine in [PlayState.instance.playerStrumline, PlayState.instance.opponentStrumline]) {
      if (strumLine != null) {
        PlayState.instance.insert(PlayState.instance.members.indexOf(strumLine) + (!isBehindStrumLinesArg ? 1 : -1), lyricObj); // The best way to handle layering hands down
      }
    }

    if (fontArg == null) {
      trace("Font property is left empty.\nApplying found default font.");
    }
  }

  function create2ndText(?text2:String, ?textColor2:Int, ?font2:String, ?fontSize2:Float, ?isCentered2:Bool, ?isBehindStrumLines2:Bool) {
    if (PlayState.instance == null || PlayState.instance.currentStage == null) return;
    // Prevents stacking the current text by deleting the current one
    if (lyricObj2nd != null) {
      lyricObj2nd.kill();
      lyricObj2nd.destroy();
      lyricObj2nd = null;
    }

    var textArg2 = text2 ?? DEFAULT_TEXT_2ND;
    var textColorArg2 = textColor2 ?? DEFAULT_COLOR_2ND;
    var fontArg2 = font2 ?? DEFAULT_FONT_2ND;
    var fontSizeArg2 = fontSize2 ?? DEFAULT_FONTSIZE_2ND;
    var isCenteredArg2 = isCentered2 ?? DEFAULT_ISCENTERED_2ND;
    var isBehindStrumLinesArg2 = isBehindStrumLines2 ?? DEFAULT_ISBEHINDSTRUMLINES_2ND;

    // I'm sure they'll have a color picker at some point
    switch (textColorArg2) {
      case 0: // Black
        textColorArg2 = 0xFF000000;
      case 1: // Blue
        textColorArg2 = 0xFF0000FF;
      case 2: // Brown
        textColorArg2 = 0xFFA52A2A;
      case 3: // Cyan
        textColorArg2 = 0xFF00FFFF;
      case 4: // Gray
        textColorArg2 = 0xFF808080;
      case 5: // Green
        textColorArg2 = 0xFF008000;
      case 6: // Lime
        textColorArg2 = 0xFF00FF00;
      case 7: // Magenta
        textColorArg2 = 0xFFFF00FF;
      case 8: // Orange
        textColorArg2 = 0xFFFFA500;
      case 9: // Purple
        textColorArg2 = 0xFF800080;
      case 10: // Red
        textColorArg2 = 0xFFFF0000;
      case 11: // Transparent
        textColorArg2 = 0x00000000;
      case 12: // White
        textColorArg2 = 0xFFFFFFFF;
      case 13: // Yellow
        textColorArg2 = 0xFFFFFF00;
      default:
        textColorArg2 = 0xFFFFFFFF;
    }

    lyricObj2nd = new FlxText(0, 0, FlxG.width);
    lyricObj2nd.text = textArg2;
    lyricObj2nd.setFormat(Paths.font(fontArg2 + ".ttf"), fontSizeArg2, textColorArg2, "center", FlxTextBorderStyle.OUTLINE, (lyricObj.borderColor != null ? lyricObj.borderColor : 0xFF000000));
    lyricObj2nd.borderSize = lyricObj?.borderSize;
    lyricObj2nd.alpha = lyricObj?.alpha;
    lyricObj2nd.letterSpacing = lyricObj?.letterSpacing;
    lyricObj2nd.italic = lyricObj?.italic;
    lyricObj2nd.bold = lyricObj?.bold;
    lyricObj2nd.antialiasing = lyricObj?.antialiasing;
    lyricObj2nd.cameras = [PlayState.instance.camHUD];
    lyricObj2nd.screenCenter(isCenteredArg2 ? 0x11 : 0x01); // I love ternary operators
    if (!isCenteredArg2 || !isCentered2) {
      lyricObj2nd.y = (Preferences.downscroll ? lyricObj2nd_YPos_DNSCROLL : lyricObj2nd_YPos_UPSCROLL); // Dynamic positioning
    } else {
      if (lyricObj != null && lyricObj.x == ((FlxG.width - lyricObj.width) / 2) && lyricObj.y == ((FlxG.height - lyricObj.height) / 2)) {
        lyricObj2nd.y += (lyricObj.height + 5);
      }
    }

    if (PlayState.instance.opponentStrumline == null) return;
    for (strumLine in [PlayState.instance.playerStrumline, PlayState.instance.opponentStrumline]) {
      if (strumLine != null) {
        PlayState.instance.insert(PlayState.instance.members.indexOf(strumLine) + (!isBehindStrumLinesArg2 ? 1 : -1), lyricObj2nd);
      }
    }

    if (fontArg2 == null) {
      trace("Font property is left empty.\nApplying found default font.");
    }
  }

  function onSongRetry(e) {
    super.onSongRetry(e);
    // prevents a bug where the text stays on-screen if you retry the song
    if (lyricObj != null) {
      lyricObj.kill();
      lyricObj.destroy();
      lyricObj = null;
    }

    if (lyricObj2nd != null) {
      lyricObj2nd.kill();
      lyricObj2nd.destroy();
      lyricObj2nd = null;
    }
  }
}